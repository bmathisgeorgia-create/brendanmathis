```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Game Arcade Collection</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background: #000; color: #fff; }
        #gameSelect { margin: 20px; padding: 10px; font-size: 16px; }
        #gameContainer { margin: 20px auto; border: 2px solid #fff; }
        canvas { display: none; background: #000; }
        #instructions { margin: 10px; font-size: 14px; }
    </style>
</head>
<body>
    <h1>Simple 2D Arcade Games Collection</h1>
    <label for="gameSelect">Choose a Game:</label>
    <select id="gameSelect">
        <option value="pong">1. Pong</option>
        <option value="asteroids">2. Asteroids</option>
        <option value="breakout">3. Breakout</option>
        <option value="duckhunt">4. Duck Hunt</option>
        <option value="pacman">5. Pac-Man</option>
        <option value="2048">6. 2048</option>
        <option value="tictactoe">7. Tic-Tac-Toe</option>
    </select>
    <div id="instructions">Use arrow keys/WASD for movement, space to shoot/pause where applicable. Mouse for aiming in Duck Hunt.</div>
    <div id="gameContainer">
        <canvas id="pongCanvas" width="800" height="600"></canvas>
        <canvas id="asteroidsCanvas" width="800" height="600"></canvas>
        <canvas id="breakoutCanvas" width="800" height="600"></canvas>
        <canvas id="duckhuntCanvas" width="800" height="600"></canvas>
        <canvas id="pacmanCanvas" width="800" height="600"></canvas>
        <canvas id="2048Canvas" width="400" height="400"></canvas>
        <canvas id="tictactoeCanvas" width="300" height="300"></canvas>
    </div>

    <script>
        const gameSelect = document.getElementById('gameSelect');
        const canvases = {
            pong: document.getElementById('pongCanvas'),
            asteroids: document.getElementById('asteroidsCanvas'),
            breakout: document.getElementById('breakoutCanvas'),
            duckhunt: document.getElementById('duckhuntCanvas'),
            pacman: document.getElementById('pacmanCanvas'),
            '2048': document.getElementById('2048Canvas'),
            tictactoe: document.getElementById('tictactoeCanvas')
        };

        let currentGame = null;
        let gameLoop = null;

        gameSelect.addEventListener('change', (e) => {
            if (currentGame) {
                cancelAnimationFrame(gameLoop);
                currentGame.stop();
            }
            const gameName = e.target.value;
            Object.values(canvases).forEach(c => c.style.display = 'none');
            canvases[gameName].style.display = 'block';
            currentGame = games[gameName];
            currentGame.init(canvases[gameName]);
            currentGame.start();
        });

        const games = {
            pong: {
                canvas: null, ctx: null,
                ball: { x: 400, y: 300, vx: 5, vy: 3, r: 10 },
                paddle1: { x: 20, y: 250, w: 10, h: 100, vy: 0 },
                paddle2: { x: 770, y: 250, w: 10, h: 100, vy: 0 },
                score1: 0, score2: 0,
                keys: {},
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    document.addEventListener('keydown', (e) => this.keys[e.key] = true);
                    document.addEventListener('keyup', (e) => this.keys[e.key] = false);
                },
                update: function() {
                    // Paddle movement
                    if (this.keys['ArrowUp'] || this.keys['w']) this.paddle1.y = Math.max(0, this.paddle1.y - 7);
                    if (this.keys['ArrowDown'] || this.keys['s']) this.paddle1.y = Math.min(500, this.paddle1.y + 7);
                    if (this.keys['w']) this.paddle2.y = Math.max(0, this.paddle2.y - 7); // AI simple
                    if (this.keys['s']) this.paddle2.y = Math.min(500, this.paddle2.y + 7);

                    // Ball movement
                    this.ball.x += this.ball.vx;
                    this.ball.y += this.ball.vy;

                    // Wall bounce
                    if (this.ball.y < this.ball.r || this.ball.y > 590 - this.ball.r) this.ball.vy *= -1;

                    // Paddle collision
                    if (this.ball.x - this.ball.r < this.paddle1.x + this.paddle1.w && this.ball.y > this.paddle1.y && this.ball.y < this.paddle1.y + this.paddle1.h) {
                        this.ball.vx *= -1;
                    }
                    if (this.ball.x + this.ball.r > this.paddle2.x && this.ball.y > this.paddle2.y && this.ball.y < this.paddle2.y + this.paddle2.h) {
                        this.ball.vx *= -1;
                    }

                    // Score
                    if (this.ball.x < 0) { this.score2++; this.resetBall(); }
                    if (this.ball.x > 800) { this.score1++; this.resetBall(); }
                },
                draw: function() {
                    this.ctx.clearRect(0, 0, 800, 600);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillRect(this.paddle1.x, this.paddle1.y, this.paddle1.w, this.paddle1.h);
                    this.ctx.fillRect(this.paddle2.x, this.paddle2.y, this.paddle2.w, this.paddle2.h);
                    this.ctx.beginPath(); this.ctx.arc(this.ball.x, this.ball.y, this.ball.r, 0, Math.PI * 2); this.ctx.fill();
                    this.ctx.fillText(`Score: ${this.score1} - ${this.score2}`, 350, 50);
                },
                resetBall: function() { this.ball.x = 400; this.ball.y = 300; this.ball.vx = this.ball.vx > 0 ? 5 : -5; this.ball.vy = Math.random() * 6 - 3; },
                start: function() { 
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {}
            },
            asteroids: {
                canvas: null, ctx: null,
                ship: { x: 400, y: 300, angle: 0, vx: 0, vy: 0, thrusting: false },
                bullets: [], asteroidNum: 5, asteroids: [],
                keys: {},
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    document.addEventListener('keydown', (e) => { this.keys[e.key] = true; if (e.key === ' ') { e.preventDefault(); this.shoot(); } });
                    document.addEventListener('keyup', (e) => this.keys[e.key] = false);
                    this.generateAsteroids();
                },
                generateAsteroids: function() {
                    this.asteroids = [];
                    for (let i = 0; i < this.asteroidNum; i++) {
                        this.asteroids.push({ x: Math.random() * 800, y: Math.random() * 600, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, r: 20 + Math.random() * 30 });
                    }
                },
                shoot: function() {
                    const rad = this.ship.angle * Math.PI / 180;
                    this.bullets.push({ x: this.ship.x + Math.cos(rad) * 20, y: this.ship.y + Math.sin(rad) * 20, vx: Math.cos(rad) * 10, vy: Math.sin(rad) * 10 });
                },
                update: function() {
                    // Ship controls
                    if (this.keys['ArrowLeft']) this.ship.angle -= 5;
                    if (this.keys['ArrowRight']) this.ship.angle += 5;
                    if (this.keys['ArrowUp']) {
                        this.ship.thrusting = true;
                        const rad = this.ship.angle * Math.PI / 180;
                        this.ship.vx += Math.cos(rad) * 0.2;
                        this.ship.vy += Math.sin(rad) * 0.2;
                    } else this.ship.thrusting = false;
                    this.ship.vx *= 0.99; this.ship.vy *= 0.99; // Friction
                    this.ship.x = (this.ship.x + this.ship.vx + 800) % 800;
                    this.ship.y = (this.ship.y + this.ship.vy + 600) % 600;

                    // Bullets
                    this.bullets = this.bullets.filter(b => {
                        b.x = (b.x + b.vx + 800) % 800;
                        b.y = (b.y + b.vy + 600) % 600;
                        return b.x > -10 && b.x < 810 && b.y > -10 && b.y < 610;
                    });

                    // Asteroids
                    this.asteroids.forEach(a => {
                        a.x = (a.x + a.vx + 800) % 800;
                        a.y = (a.y + a.vy + 600) % 600;
                    });

                    // Collisions
                    this.bullets.forEach((b, bi) => {
                        this.asteroids.forEach((a, ai) => {
                            const dx = b.x - a.x, dy = b.y - a.y;
                            if (Math.sqrt(dx*dx + dy*dy) < a.r) {
                                this.asteroids.splice(ai, 1);
                                this.bullets.splice(bi, 1);
                            }
                        });
                    });

                    if (this.asteroids.length === 0) this.generateAsteroids();
                },
                draw: function() {
                    this.ctx.clearRect(0, 0, 800, 600);
                    this.ctx.strokeStyle = '#fff';

                    // Ship
                    this.ctx.save();
                    this.ctx.translate(this.ship.x, this.ship.y);
                    this.ctx.rotate(this.ship.angle * Math.PI / 180);
                    this.ctx.beginPath();
                    this.ctx.moveTo(20, 0); this.ctx.lineTo(-10, 10); this.ctx.lineTo(-10, -10); this.ctx.closePath();
                    this.ctx.stroke();
                    if (this.ship.thrusting) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(-10, 0); this.ctx.lineTo(-30, 0);
                        this.ctx.stroke();
                    }
                    this.ctx.restore();

                    // Bullets
                    this.bullets.forEach(b => {
                        this.ctx.beginPath(); this.ctx.arc(b.x, b.y, 2, 0, Math.PI * 2); this.ctx.fillStyle = '#fff'; this.ctx.fill();
                    });

                    // Asteroids
                    this.asteroids.forEach(a => {
                        this.ctx.beginPath(); this.ctx.arc(a.x, a.y, a.r, 0, Math.PI * 2); this.ctx.stroke();
                    });
                },
                start: function() {
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {}
            },
            breakout: {
                canvas: null, ctx: null,
                ball: { x: 400, y: 500, vx: 4, vy: -4, r: 8 },
                paddle: { x: 350, y: 550, w: 100, h: 10 },
                bricks: [],
                keys: {},
                score: 0,
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    document.addEventListener('keydown', (e) => this.keys[e.key] = true);
                    document.addEventListener('keyup', (e) => this.keys[e.key] = false);
                    this.generateBricks();
                },
                generateBricks: function() {
                    this.bricks = [];
                    for (let row = 0; row < 5; row++) {
                        for (let col = 0; col < 10; col++) {
                            this.bricks.push({ x: col * 80, y: row * 30 + 50, w: 80, h: 30, hit: false });
                        }
                    }
                },
                update: function() {
                    // Paddle
                    if (this.keys['ArrowLeft']) this.paddle.x = Math.max(0, this.paddle.x - 7);
                    if (this.keys['ArrowRight']) this.paddle.x = Math.min(700, this.paddle.x + 7);

                    // Ball
                    this.ball.x += this.ball.vx;
                    this.ball.y += this.ball.vy;

                    // Wall bounce
                    if (this.ball.x < this.ball.r || this.ball.x > 792 - this.ball.r) this.ball.vx *= -1;
                    if (this.ball.y < this.ball.r) this.ball.vy *= -1;
                    if (this.ball.y > 592 - this.ball.r) this.resetBall();

                    // Paddle collision
                    if (this.ball.y + this.ball.r > this.paddle.y && this.ball.x > this.paddle.x && this.ball.x < this.paddle.x + this.paddle.w) {
                        this.ball.vy *= -1;
                        this.ball.vx += (this.ball.x - (this.paddle.x + this.paddle.w / 2)) * 0.1;
                    }

                    // Brick collision
                    this.bricks.forEach(b => {
                        if (!b.hit && this.ball.x > b.x && this.ball.x < b.x + b.w && this.ball.y > b.y && this.ball.y < b.y + b.h) {
                            b.hit = true;
                            this.ball.vy *= -1;
                            this.score++;
                        }
                    });
                    this.bricks = this.bricks.filter(b => !b.hit);
                    if (this.bricks.length === 0) this.generateBricks();
                },
                draw: function() {
                    this.ctx.clearRect(0, 0, 800, 600);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillRect(this.paddle.x, this.paddle.y, this.paddle.w, this.paddle.h);
                    this.ctx.beginPath(); this.ctx.arc(this.ball.x, this.ball.y, this.ball.r, 0, Math.PI * 2); this.ctx.fill();
                    this.bricks.forEach(b => {
                        if (!b.hit) {
                            this.ctx.fillStyle = '#f00';
                            this.ctx.fillRect(b.x, b.y, b.w, b.h);
                        }
                    });
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillText(`Score: ${this.score}`, 10, 20);
                },
                resetBall: function() { this.ball.x = 400; this.ball.y = 500; this.ball.vx = 4; this.ball.vy = -4; },
                start: function() {
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {}
            },
            duckhunt: {
                canvas: null, ctx: null,
                ducks: [],
                crosshair: { x: 400, y: 300 },
                score: 0,
                gameTime: 0,
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    canvas.addEventListener('mousemove', (e) => {
                        const rect = canvas.getBoundingClientRect();
                        this.crosshair.x = e.clientX - rect.left;
                        this.crosshair.y = e.clientY - rect.top;
                    });
                    canvas.addEventListener('click', () => this.shoot());
                    this.spawnDuck();
                },
                spawnDuck: function() {
                    if (this.gameTime % 200 === 0 && Math.random() > 0.5) {
                        this.ducks.push({ x: Math.random() > 0.5 ? -50 : 850, y: Math.random() * 500 + 50, vx: Math.random() * 4 + 2, vy: (Math.random() - 0.5) * 2, alive: true });
                    }
                },
                shoot: function() {
                    this.ducks.forEach((d, i) => {
                        const dx = this.crosshair.x - d.x, dy = this.crosshair.y - d.y;
                        if (d.alive && Math.sqrt(dx*dx + dy*dy) < 30) {
                            d.alive = false;
                            this.score += 100;
                            setTimeout(() => this.ducks.splice(i, 1), 500);
                        }
                    });
                },
                update: function() {
                    this.gameTime++;
                    this.spawnDuck();
                    this.ducks.forEach(d => {
                        d.x += d.vx * (d.x < 0 ? 1 : -1);
                        d.y += d.vy;
                        if (d.y < 0 || d.y > 600) d.vy *= -1;
                        if (d.x < -50 || d.x > 850) d.alive = false;
                    });
                    this.ducks = this.ducks.filter(d => d.alive && d.x > -50 && d.x < 850);
                },
                draw: function() {
                    this.ctx.clearRect(0, 0, 800, 600);
                    this.ctx.fillStyle = '#0f0'; // Grass
                    this.ctx.fillRect(0, 550, 800, 50);
                    this.ctx.fillStyle = '#87CEEB'; // Sky
                    this.ctx.fillRect(0, 0, 800, 550);

                    // Ducks
                    this.ducks.forEach(d => {
                        this.ctx.fillStyle = d.alive ? '#ff0' : '#f00';
                        this.ctx.beginPath();
                        this.ctx.ellipse(d.x, d.y, 20, 15, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.fillStyle = '#000';
                        this.ctx.fillRect(d.x - 5, d.y - 5, 2, 2); // Eye
                    });

                    // Crosshair
                    this.ctx.strokeStyle = '#f00';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.crosshair.x - 10, this.crosshair.y); this.ctx.lineTo(this.crosshair.x + 10, this.crosshair.y);
                    this.ctx.moveTo(this.crosshair.x, this.crosshair.y - 10); this.ctx.lineTo(this.crosshair.x, this.crosshair.y + 10);
                    this.ctx.stroke();

                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillText(`Score: ${this.score}`, 10, 20);
                },
                start: function() {
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {}
            },
            pacman: {
                canvas: null, ctx: null,
                pacman: { x: 40, y: 300, dir: 0, nextDir: 0, mouth: 0 }, // 0:right,1:down,2:left,3:up
                ghosts: [{x:400,y:300,vx:2,vy:0,color:'#f00'}],
                dots: [],
                score: 0,
                map: [ // Simple maze 1=wall, 0=dot, .=empty
                    '1111111111111111',
                    '1000000000000001',
                    '1.0.1.0.1.0.1.0',
                    '1000000000000001',
                    '1.0.1.0.1.0.1.0',
                    '1000000000000001',
                    '1.0.1.0.1.0.1.0',
                    '1000000000000001',
                    '1111111111111111'
                ].join('').split('').map(c => c==='1'?1:c==='.'?2:0),
                tileSize: 40,
                keys: {},
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    document.addEventListener('keydown', (e) => { this.keys[e.key] = true; e.preventDefault(); });
                    this.generateDots();
                },
                generateDots: function() {
                    this.dots = [];
                    for (let y = 0; y < 9; y++) {
                        for (let x = 0; x < 16; x++) {
                            if (this.map[y*16 + x] === 0) this.dots.push({x: x*this.tileSize + 20, y: y*this.tileSize + 20});
                        }
                    }
                },
                update: function() {
                    // Pacman direction
                    if (this.keys['ArrowRight']) this.nextDir = 0;
                    if (this.keys['ArrowDown']) this.nextDir = 1;
                    if (this.keys['ArrowLeft']) this.nextDir = 2;
                    if (this.keys['ArrowUp']) this.nextDir = 3;

                    // Move if possible
                    let nx = this.pacman.x, ny = this.pacman.y;
                    if (this.nextDir === 0) nx += 2;
                    if (this.nextDir === 1) ny += 2;
                    if (this.nextDir === 2) nx -= 2;
                    if (this.nextDir === 3) ny -= 2;
                    const tx = Math.floor(nx / this.tileSize), ty = Math.floor(ny / this.tileSize);
                    if (tx >= 0 && tx < 16 && ty >= 0 && ty < 9 && this.map[ty*16 + tx] !== 1) {
                        this.pacman.dir = this.nextDir;
                        this.pacman.x = nx;
                        this.pacman.y = ny;
                    }

                    // Eat dots
                    this.dots.forEach((d, i) => {
                        const dx = this.pacman.x - d.x, dy = this.pacman.y - d.y;
                        if (Math.sqrt(dx*dx + dy*dy) < 15) {
                            this.dots.splice(i, 1);
                            this.score += 10;
                            this.map[Math.floor(d.y / this.tileSize)*16 + Math.floor(d.x / this.tileSize)] = 2;
                        }
                    });

                    // Ghosts simple chase
                    this.ghosts.forEach(g => {
                        const dx = this.pacman.x - g.x, dy = this.pacman.y - g.y;
                        g.vx = Math.sign(dx) * 1;
                        g.vy = Math.sign(dy) * 1;
                        g.x += g.vx;
                        g.y += g.vy;
                        // Wrap or simple collision with walls omitted for brevity
                    });

                    this.pacman.mouth = (this.pacman.mouth + 0.2) % (Math.PI * 2);
                },
                draw: function() {
                    this.ctx.clearRect(0, 0, 800, 600);

                    // Map
                    for (let y = 0; y < 9; y++) {
                        for (let x = 0; x < 16; x++) {
                            const val = this.map[y*16 + x];
                            if (val === 1) {
                                this.ctx.fillStyle = '#00f';
                                this.ctx.fillRect(x*this.tileSize, y*this.tileSize, this.tileSize, this.tileSize);
                            }
                        }
                    }

                    // Dots
                    this.ctx.fillStyle = '#ff0';
                    this.dots.forEach(d => {
                        this.ctx.beginPath(); this.ctx.arc(d.x, d.y, 3, 0, Math.PI * 2); this.ctx.fill();
                    });

                    // Pacman
                    this.ctx.fillStyle = '#ff0';
                    this.ctx.save();
                    this.ctx.translate(this.pacman.x, this.pacman.y);
                    this.ctx.rotate((this.pacman.dir * 90) * Math.PI / 180);
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 20, this.pacman.mouth / 2, -this.pacman.mouth / 2);
                    this.ctx.lineTo(0, 0);
                    this.ctx.fill();
                    this.ctx.restore();

                    // Ghosts
                    this.ghosts.forEach(g => {
                        this.ctx.fillStyle = g.color;
                        this.ctx.beginPath(); this.ctx.arc(g.x, g.y, 20, 0, Math.PI * 2); this.ctx.fill();
                    });

                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillText(`Score: ${this.score}`, 10, 20);
                },
                start: function() {
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {}
            },
            '2048': {
                canvas: null, ctx: null,
                board: [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]],
                score: 0,
                keys: {},
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    document.addEventListener('keydown', (e) => { this.keys[e.key] = true; e.preventDefault(); });
                    this.addRandomTile();
                    this.addRandomTile();
                },
                addRandomTile: function() {
                    const empty = [];
                    this.board.forEach((row, y) => row.forEach((val, x) => { if (val === 0) empty.push({x,y}); }));
                    if (empty.length) {
                        const pos = empty[Math.floor(Math.random() * empty.length)];
                        this.board[pos.y][pos.x] = Math.random() > 0.5 ? 2 : 4;
                    }
                },
                move: function(dir) {
                    let moved = false;
                    const newBoard = this.board.map(row => [...row]);
                    if (dir === 'ArrowLeft' || dir === 'a') {
                        for (let y = 0; y < 4; y++) {
                            let row = this.board[y].filter(n => n !== 0);
                            for (let i = 0; i < row.length - 1; i++) {
                                if (row[i] === row[i+1]) { row[i] *= 2; this.score += row[i]; row.splice(i+1, 1); moved = true; }
                            }
                            while (row.length < 4) row.push(0);
                            newBoard[y] = row;
                        }
                    }
                    // Similar for other directions - simplified, add right/up/down logic here
                    // For brevity, only left implemented fully; others similar with rotations
                    if (dir === 'ArrowRight' || dir === 'd') {
                        for (let y = 0; y < 4; y++) {
                            let row = this.board[y].filter(n => n !== 0).reverse();
                            for (let i = 0; i < row.length - 1; i++) {
                                if (row[i] === row[i+1]) { row[i] *= 2; this.score += row[i]; row.splice(i+1, 1); moved = true; }
                            }
                            while (row.length < 4) row.push(0);
                            newBoard[y] = row.reverse();
                        }
                    }
                    if (dir === 'ArrowUp' || dir === 'w') {
                        for (let x = 0; x < 4; x++) {
                            let col = [this.board[0][x], this.board[1][x], this.board[2][x], this.board[3][x]].filter(n => n !== 0);
                            for (let i = 0; i < col.length - 1; i++) {
                                if (col[i] === col[i+1]) { col[i] *= 2; this.score += col[i]; col.splice(i+1, 1); moved = true; }
                            }
                            while (col.length < 4) col.unshift(0);
                            for (let y = 0; y < 4; y++) newBoard[y][x] = col[y];
                        }
                    }
                    if (dir === 'ArrowDown' || dir === 's') {
                        for (let x = 0; x < 4; x++) {
                            let col = [this.board[0][x], this.board[1][x], this.board[2][x], this.board[3][x]].filter(n => n !== 0).reverse();
                            for (let i = 0; i < col.length - 1; i++) {
                                if (col[i] === col[i+1]) { col[i] *= 2; this.score += col[i]; col.splice(i+1, 1); moved = true; }
                            }
                            while (col.length < 4) col.push(0);
                            for (let y = 0; y < 4; y++) newBoard[y][x] = col[3-y];
                        }
                    }
                    this.board = newBoard;
                    if (moved) this.addRandomTile();
                },
                update: function() {
                    if (this.keys['ArrowLeft'] || this.keys['a']) { this.move('ArrowLeft'); this.keys['ArrowLeft'] = this.keys['a'] = false; }
                    if (this.keys['ArrowRight'] || this.keys['d']) { this.move('ArrowRight'); this.keys['ArrowRight'] = this.keys['d'] = false; }
                    if (this.keys['ArrowUp'] || this.keys['w']) { this.move('ArrowUp'); this.keys['ArrowUp'] = this.keys['w'] = false; }
                    if (this.keys['ArrowDown'] || this.keys['s']) { this.move('ArrowDown'); this.keys['ArrowDown'] = this.keys['s'] = false; }
                },
                draw: function() {
                    this.ctx.clearRect(0, 0, 400, 400);
                    const ts = 100;
                    for (let y = 0; y < 4; y++) {
                        for (let x = 0; x < 4; x++) {
                            const val = this.board[y][x];
                            this.ctx.fillStyle = val ? `hsl(${(Math.log2(val) * 30) % 360}, 70%, 70%)` : '#ccc';
                            this.ctx.fillRect(x*ts, y*ts, ts, ts);
                            this.ctx.strokeStyle = '#000';
                            this.ctx.strokeRect(x*ts, y*ts, ts, ts);
                            if (val) {
                                this.ctx.fillStyle = '#000';
                                this.ctx.font = 'bold 40px Arial';
                                this.ctx.textAlign = 'center';
                                this.ctx.fillText(val, x*ts + 50, y*ts + 65);
                            }
                        }
                    }
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '20px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(`Score: ${this.score}`, 10, 30);
                },
                start: function() {
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {}
            },
            tictactoe: {
                canvas: null, ctx: null,
                board: [[0,0,0],[0,0,0],[0,0,0]],
                currentPlayer: 1, // 1:X, -1:O
                gameOver: false,
                winner: 0,
                keys: {},
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    canvas.addEventListener('click', (e) => this.handleClick(e));
                },
                handleClick: function(e) {
                    if (this.gameOver) return;
                    const rect = this.canvas.getBoundingClientRect();
                    const x = Math.floor((e.clientX - rect.left) / 100);
                    const y = Math.floor((e.clientY - rect.top) / 100);
                    if (this.board[y][x] === 0) {
                        this.board[y][x] = this.currentPlayer;
                        this.checkWin();
                        if (!this.gameOver) this.currentPlayer *= -1;
                    }
                },
                checkWin: function() {
                    const lines = [
                        [[0,0],[0,1],[0,2]], [[1,0],[1,1],[1,2]], [[2,0],[2,1],[2,2]], // rows
                        [[0,0],[1,0],[2,0]], [[0,1],[1,1],[2,1]], [[0,2],[1,2],[2,2]], // cols
                        [[0,0],[1,1],[2,2]], [[0,2],[1,1],[2,0]] // diags
                    ];
                    for (let line of lines) {
                        const [a,b,c] = line.map(([y,x]) => this.board[y][x]);
                        if (a === b && b === c && a !== 0) {
                            this.winner = a;
                            this.gameOver = true;
                            return;
                        }
                    }
                    if (this.board.flat().every(cell => cell !== 0)) {
                        this.gameOver = true;
                    }
                },
                update: function() {
                    // AI simple: random move for O
                    if (this.currentPlayer === -1 && !this.gameOver && Math.random() < 0.02) { // Occasional AI move
                        const empty = [];
                        this.board.forEach((row,y) => row.forEach((cell,x) => { if (cell === 0) empty.push([y,x]); }));
                        if (empty.length) {
                            const [y,x] = empty[Math.floor(Math.random() * empty.length)];
                            this.board[y][x] = -1;
                            this.checkWin();
                            if (!this.gameOver) this.currentPlayer = 1;
                        }
                    }
                },
                draw: function() {
                    this.ctx.clearRect(0, 0, 300, 300);
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 5;
                    // Grid
                    this.ctx.beginPath();
                    this.ctx.moveTo(100, 0); this.ctx.lineTo(100, 300);
                    this.ctx.moveTo(200, 0); this.ctx.lineTo(200, 300);
                    this.ctx.moveTo(0, 100); this.ctx.lineTo(300, 100);
                    this.ctx.moveTo(0, 200); this.ctx.lineTo(300, 200);
                    this.ctx.stroke();

                    // Marks
                    this.board.forEach((row, y) => {
                        row.forEach((cell, x) => {
                            if (cell === 1) {
                                this.ctx.font = 'bold 80px Arial';
                                this.ctx.textAlign = 'center';
                                this.ctx.fillText('X', x*100 + 50, (y+1)*100 - 20);
                            } else if (cell === -1) {
                                this.ctx.beginPath();
                                this.ctx.arc(x*100 + 50, y*100 + 50, 30, 0, Math.PI * 2);
                                this.ctx.stroke();
                            }
                        });
                    });

                    if (this.gameOver) {
                        this.ctx.fillStyle = '#fff';
                        this.ctx.font = '20px Arial';
                        this.ctx.textAlign = 'center';
                        if (this.winner > 0) this.ctx.fillText('X Wins!', 150, 280);
                        else if (this.winner < 0) this.ctx.fillText('O Wins!', 150, 280);
                        else this.ctx.fillText('Draw!', 150, 280);
                    }
                },
                start: function() {
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {
                    this.board = [[0,0,0],[0,0,0],[0,0,0]];
                    this.currentPlayer = 1;
                    this.gameOver = false;
                    this.winner = 0;
                }
            }
        };

        // Start with first game
        gameSelect.dispatchEvent(new Event('change'));
    </script>
</body>
</html>
```
