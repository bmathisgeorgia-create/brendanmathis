<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Arcade Collection</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            background: linear-gradient(to bottom, #0a0a2a, #1a1a4a);
            color: #fff;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #ffcc00;
            text-shadow: 0 0 10px #ffcc00, 0 0 20px #ff9900;
            margin-bottom: 20px;
        }
        #gameSelect, #restart {
            background: #222;
            color: #fff;
            border: 1px solid #fff;
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
            margin: 10px;
            cursor: pointer;
        }
        #gameSelect:hover, #restart:hover {
            background: #333;
        }
        #instructions {
            margin: 10px;
            font-size: 14px;
            max-width: 800px;
            margin: 0 auto 20px;
        }
        #gameContainer {
            margin: 20px auto;
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            width: 800px;
            height: 600px;
        }
        canvas {
            display: none;
            background: #000;
        }
    </style>
</head>
<body>
    <h1>Ultimate Arcade Collection</h1>
    <label for="gameSelect">Choose a Game:</label>
    <select id="gameSelect">
        <option value="pong">1. Pong</option>
        <option value="asteroids">2. Asteroids</option>
        <option value="breakout">3. Breakout</option>
        <option value="duckhunt">4. Duck Hunt</option>
        <option value="pacman">5. Pac-Man</option>
        <option value="2048">6. 2048</option>
        <option value="tictactoe">7. Tic-Tac-Toe</option>
    </select>
    <button id="restart">Restart Game</button>
    <div id="instructions">Use arrow keys for player 1 / WASD for player 2 where applicable. Space to shoot in Asteroids. Mouse for Duck Hunt and Tic-Tac-Toe. Arrow keys for 2048 and Pac-Man.</div>
    <div id="gameContainer">
        <canvas id="pongCanvas" width="800" height="600"></canvas>
        <canvas id="asteroidsCanvas" width="800" height="600"></canvas>
        <canvas id="breakoutCanvas" width="800" height="600"></canvas>
        <canvas id="duckhuntCanvas" width="800" height="600"></canvas>
        <canvas id="pacmanCanvas" width="800" height="600"></canvas>
        <canvas id="2048Canvas" width="400" height="400"></canvas>
        <canvas id="tictactoeCanvas" width="300" height="300"></canvas>
    </div>

    <script>
        const gameSelect = document.getElementById('gameSelect');
        const restartBtn = document.getElementById('restart');
        const canvases = {
            pong: document.getElementById('pongCanvas'),
            asteroids: document.getElementById('asteroidsCanvas'),
            breakout: document.getElementById('breakoutCanvas'),
            duckhunt: document.getElementById('duckhuntCanvas'),
            pacman: document.getElementById('pacmanCanvas'),
            '2048': document.getElementById('2048Canvas'),
            tictactoe: document.getElementById('tictactoeCanvas')
        };

        let currentGame = null;
        let gameLoop = null;

        gameSelect.addEventListener('change', switchGame);

        restartBtn.addEventListener('click', () => {
            if (currentGame) {
                cancelAnimationFrame(gameLoop);
                currentGame.stop();
                currentGame.init(canvases[gameSelect.value]);
                currentGame.start();
            }
        });

        function switchGame(e) {
            if (currentGame) {
                cancelAnimationFrame(gameLoop);
                currentGame.stop();
            }
            const gameName = e ? e.target.value : 'pong';
            Object.values(canvases).forEach(c => c.style.display = 'none');
            canvases[gameName].style.display = 'block';
            currentGame = games[gameName];
            currentGame.init(canvases[gameName]);
            currentGame.start();
        }

        const games = {
            pong: {
                canvas: null, ctx: null,
                ball: { x: 400, y: 300, vx: 5, vy: 3, r: 10 },
                paddle1: { x: 20, y: 250, w: 10, h: 100, vy: 0 },
                paddle2: { x: 770, y: 250, w: 10, h: 100, vy: 0 },
                score1: 0, score2: 0,
                keys: {},
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    this.reset();
                    document.addEventListener('keydown', (e) => this.keys[e.key] = true);
                    document.addEventListener('keyup', (e) => this.keys[e.key] = false);
                },
                reset: function() {
                    this.ball = { x: 400, y: 300, vx: 5, vy: 3, r: 10 };
                    this.paddle1 = { x: 20, y: 250, w: 10, h: 100, vy: 0 };
                    this.paddle2 = { x: 770, y: 250, w: 10, h: 100, vy: 0 };
                    this.score1 = 0;
                    this.score2 = 0;
                },
                update: function() {
                    if (this.keys['ArrowUp']) this.paddle1.y = Math.max(0, this.paddle1.y - 7);
                    if (this.keys['ArrowDown']) this.paddle1.y = Math.min(500, this.paddle1.y + 7);
                    if (this.keys['w']) this.paddle2.y = Math.max(0, this.paddle2.y - 7);
                    if (this.keys['s']) this.paddle2.y = Math.min(500, this.paddle2.y + 7);

                    this.ball.x += this.ball.vx;
                    this.ball.y += this.ball.vy;

                    if (this.ball.y < this.ball.r || this.ball.y > 590 - this.ball.r) this.ball.vy *= -1;

                    if (this.ball.x - this.ball.r < this.paddle1.x + this.paddle1.w &&
                        this.ball.x + this.ball.r > this.paddle1.x &&
                        this.ball.y - this.ball.r < this.paddle1.y + this.paddle1.h &&
                        this.ball.y + this.ball.r > this.paddle1.y) {
                        this.ball.vx *= -1.1;
                    }
                    if (this.ball.x + this.ball.r > this.paddle2.x &&
                        this.ball.x - this.ball.r < this.paddle2.x + this.paddle2.w &&
                        this.ball.y - this.ball.r < this.paddle2.y + this.paddle2.h &&
                        this.ball.y + this.ball.r > this.paddle2.y) {
                        this.ball.vx *= -1.1;
                    }

                    if (this.ball.x < 0) { this.score2++; this.resetBall(); }
                    if (this.ball.x > 800) { this.score1++; this.resetBall(); }
                },
                draw: function() {
                    this.ctx.clearRect(0, 0, 800, 600);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillRect(this.paddle1.x, this.paddle1.y, this.paddle1.w, this.paddle1.h);
                    this.ctx.fillRect(this.paddle2.x, this.paddle2.y, this.paddle2.w, this.paddle2.h);
                    this.ctx.beginPath(); this.ctx.arc(this.ball.x, this.ball.y, this.ball.r, 0, Math.PI * 2); this.ctx.fill();
                    this.ctx.font = '20px Arial';
                    this.ctx.fillText(`Player 1: ${this.score1} - Player 2: ${this.score2}`, 250, 50);
                },
                resetBall: function() {
                    this.ball.x = 400;
                    this.ball.y = 300;
                    this.ball.vx = Math.random() > 0.5 ? 5 : -5;
                    this.ball.vy = (Math.random() - 0.5) * 6;
                },
                start: function() {
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {
                    this.reset();
                }
            },
            asteroids: {
                canvas: null, ctx: null,
                ship: { x: 400, y: 300, angle: 0, vx: 0, vy: 0, thrusting: false },
                bullets: [], asteroidNum: 5, asteroids: [],
                score: 0,
                keys: {},
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    this.score = 0;
                    document.addEventListener('keydown', (e) => { this.keys[e.key] = true; if (e.key === ' ') { e.preventDefault(); this.shoot(); } });
                    document.addEventListener('keyup', (e) => this.keys[e.key] = false);
                    this.generateAsteroids();
                },
                generateAsteroids: function() {
                    this.asteroids = [];
                    for (let i = 0; i < this.asteroidNum; i++) {
                        let x = Math.random() * 800, y = Math.random() * 600;
                        while (Math.abs(x - this.ship.x) < 100 && Math.abs(y - this.ship.y) < 100) {
                            x = Math.random() * 800; y = Math.random() * 600;
                        }
                        this.asteroids.push({ x, y, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, r: 20 + Math.random() * 30 });
                    }
                },
                shoot: function() {
                    const rad = this.ship.angle * Math.PI / 180;
                    this.bullets.push({ x: this.ship.x + Math.cos(rad) * 20, y: this.ship.y + Math.sin(rad) * 20, vx: Math.cos(rad) * 10 + this.ship.vx, vy: Math.sin(rad) * 10 + this.ship.vy });
                },
                update: function() {
                    if (this.keys['ArrowLeft']) this.ship.angle -= 5;
                    if (this.keys['ArrowRight']) this.ship.angle += 5;
                    if (this.keys['ArrowUp']) {
                        this.ship.thrusting = true;
                        const rad = this.ship.angle * Math.PI / 180;
                        this.ship.vx += Math.cos(rad) * 0.2;
                        this.ship.vy += Math.sin(rad) * 0.2;
                    } else this.ship.thrusting = false;
                    this.ship.vx *= 0.99; this.ship.vy *= 0.99;
                    this.ship.x = (this.ship.x + this.ship.vx + 800) % 800;
                    this.ship.y = (this.ship.y + this.ship.vy + 600) % 600;

                    this.bullets = this.bullets.filter(b => {
                        b.x += b.vx;
                        b.y += b.vy;
                        if (b.x < 0 || b.x > 800 || b.y < 0 || b.y > 600) return false;
                        return true;
                    });

                    this.asteroids.forEach(a => {
                        a.x = (a.x + a.vx + 800) % 800;
                        a.y = (a.y + a.vy + 600) % 600;
                    });

                    for (let bi = this.bullets.length - 1; bi >= 0; bi--) {
                        const b = this.bullets[bi];
                        for (let ai = this.asteroids.length - 1; ai >= 0; ai--) {
                            const a = this.asteroids[ai];
                            const dx = b.x - a.x, dy = b.y - a.y;
                            if (Math.sqrt(dx*dx + dy*dy) < a.r) {
                                this.asteroids.splice(ai, 1);
                                this.bullets.splice(bi, 1);
                                this.score += 10;
                                break;
                            }
                        }
                    }

                    this.asteroids.forEach(a => {
                        const dx = this.ship.x - a.x, dy = this.ship.y - a.y;
                        if (Math.sqrt(dx*dx + dy*dy) < a.r + 15) {
                            alert(`Game Over! Score: ${this.score}`);
                            this.ship.x = 400; this.ship.y = 300; this.ship.vx = 0; this.ship.vy = 0; this.ship.angle = 0;
                            this.score = 0;
                            this.generateAsteroids();
                        }
                    });

                    if (this.asteroids.length === 0) {
                        this.asteroidNum += 2;
                        this.generateAsteroids();
                    }
                },
                draw: function() {
                    this.ctx.clearRect(0, 0, 800, 600);
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.fillStyle = '#fff';

                    this.ctx.save();
                    this.ctx.translate(this.ship.x, this.ship.y);
                    this.ctx.rotate(this.ship.angle * Math.PI / 180);
                    this.ctx.beginPath();
                    this.ctx.moveTo(20, 0); this.ctx.lineTo(-10, 10); this.ctx.lineTo(-10, -10); this.ctx.closePath();
                    this.ctx.stroke();
                    if (this.ship.thrusting) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(-10, 5); this.ctx.lineTo(-30, 0); this.ctx.lineTo(-10, -5);
                        this.ctx.fillStyle = '#ff9900';
                        this.ctx.fill();
                    }
                    this.ctx.restore();

                    this.bullets.forEach(b => {
                        this.ctx.beginPath(); this.ctx.arc(b.x, b.y, 2, 0, Math.PI * 2); this.ctx.fill();
                    });

                    this.asteroids.forEach(a => {
                        this.ctx.beginPath(); this.ctx.arc(a.x, a.y, a.r, 0, Math.PI * 2); this.ctx.stroke();
                    });

                    this.ctx.font = '20px Arial';
                    this.ctx.fillText(`Score: ${this.score}`, 10, 30);
                },
                start: function() {
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {
                    this.score = 0;
                    this.asteroidNum = 5;
                }
            },
            breakout: {
                canvas: null, ctx: null,
                ball: { x: 400, y: 500, vx: 4, vy: -4, r: 8 },
                paddle: { x: 350, y: 550, w: 100, h: 10 },
                bricks: [],
                keys: {},
                score: 0,
                lives: 3,
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    this.lives = 3;
                    this.score = 0;
                    document.addEventListener('keydown', (e) => this.keys[e.key] = true);
                    document.addEventListener('keyup', (e) => this.keys[e.key] = false);
                    this.generateBricks();
                },
                generateBricks: function() {
                    this.bricks = [];
                    for (let row = 0; row < 5; row++) {
                        for (let col = 0; col < 10; col++) {
                            this.bricks.push({ x: col * 80 + 10, y: row * 30 + 50, w: 70, h: 20, hit: false, color: `hsl(${row * 30}, 100%, 50%)` });
                        }
                    }
                },
                update: function() {
                    if (this.keys['ArrowLeft']) this.paddle.x = Math.max(0, this.paddle.x - 7);
                    if (this.keys['ArrowRight']) this.paddle.x = Math.min(700, this.paddle.x + 7);

                    this.ball.x += this.ball.vx;
                    this.ball.y += this.ball.vy;

                    if (this.ball.x < this.ball.r || this.ball.x > 792 - this.ball.r) this.ball.vx *= -1;
                    if (this.ball.y < this.ball.r) this.ball.vy *= -1;
                    if (this.ball.y > 592 - this.ball.r) {
                        this.lives--;
                        if (this.lives <= 0) {
                            alert(`Game Over! Score: ${this.score}`);
                            this.lives = 3;
                            this.score = 0;
                            this.generateBricks();
                        }
                        this.resetBall();
                    }

                    if (this.ball.y + this.ball.r > this.paddle.y &&
                        this.ball.y - this.ball.r < this.paddle.y + this.paddle.h &&
                        this.ball.x > this.paddle.x &&
                        this.ball.x < this.paddle.x + this.paddle.w) {
                        this.ball.vy *= -1;
                        this.ball.vx += (this.ball.x - (this.paddle.x + this.paddle.w / 2)) * 0.1;
                    }

                    this.bricks.forEach(b => {
                        if (!b.hit &&
                            this.ball.x + this.ball.r > b.x &&
                            this.ball.x - this.ball.r < b.x + b.w &&
                            this.ball.y + this.ball.r > b.y &&
                            this.ball.y - this.ball.r < b.y + b.h) {
                            b.hit = true;
                            this.ball.vy *= -1;
                            this.score += 10;
                        }
                    });
                    this.bricks = this.bricks.filter(b => !b.hit);
                    if (this.bricks.length === 0) this.generateBricks();
                },
                draw: function() {
                    this.ctx.clearRect(0, 0, 800, 600);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillRect(this.paddle.x, this.paddle.y, this.paddle.w, this.paddle.h);
                    this.ctx.beginPath(); this.ctx.arc(this.ball.x, this.ball.y, this.ball.r, 0, Math.PI * 2); this.ctx.fill();
                    this.bricks.forEach(b => {
                        if (!b.hit) {
                            this.ctx.fillStyle = b.color;
                            this.ctx.fillRect(b.x, b.y, b.w, b.h);
                        }
                    });
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '20px Arial';
                    this.ctx.fillText(`Score: ${this.score} Lives: ${this.lives}`, 10, 30);
                },
                resetBall: function() { this.ball.x = 400; this.ball.y = 500; this.ball.vx = 4; this.ball.vy = -4; },
                start: function() {
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {
                    this.lives = 3;
                    this.score = 0;
                }
            },
            duckhunt: {
                canvas: null, ctx: null,
                ducks: [],
                crosshair: { x: 400, y: 300 },
                score: 0,
                gameTime: 0,
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    this.score = 0;
                    this.gameTime = 0;
                    canvas.addEventListener('mousemove', (e) => {
                        const rect = canvas.getBoundingClientRect();
                        this.crosshair.x = e.clientX - rect.left;
                        this.crosshair.y = e.clientY - rect.top;
                    });
                    canvas.addEventListener('click', () => this.shoot());
                },
                spawnDuck: function() {
                    if (this.gameTime % 100 === 0) {
                        const startRight = Math.random() > 0.5;
                        this.ducks.push({
                            x: startRight ? 850 : -50,
                            y: Math.random() * 400 + 50,
                            vx: Math.random() * 3 + 2,
                            vy: (Math.random() - 0.5) * 2,
                            dir: startRight ? -1 : 1,
                            alive: true,
                            hitTime: 0
                        });
                    }
                },
                shoot: function() {
                    this.ducks.forEach(d => {
                        const dx = this.crosshair.x - d.x, dy = this.crosshair.y - d.y;
                        if (d.alive && Math.sqrt(dx*dx + dy*dy) < 30) {
                            d.alive = false;
                            d.hitTime = this.gameTime;
                            d.vx = 0;
                            d.vy = 5;
                            d.dir = 0;
                            this.score += 100;
                        }
                    });
                },
                update: function() {
                    this.gameTime++;
                    this.spawnDuck();
                    this.ducks.forEach(d => {
                        d.x += d.vx * d.dir;
                        d.y += d.vy;
                        if (d.alive && (d.y < 0 || d.y > 550)) d.vy *= -1;
                    });
                    this.ducks = this.ducks.filter(d => {
                        if (!d.alive && this.gameTime - d.hitTime > 30) return false;
                        if (d.alive && (d.x < -50 || d.x > 850)) return false;
                        if (d.y > 650) return false;
                        return true;
                    });
                },
                draw: function() {
                    this.ctx.clearRect(0, 0, 800, 600);
                    this.ctx.fillStyle = '#87CEEB'; // Sky
                    this.ctx.fillRect(0, 0, 800, 550);
                    this.ctx.fillStyle = '#0f0'; // Grass
                    this.ctx.fillRect(0, 550, 800, 50);

                    this.ducks.forEach(d => {
                        this.ctx.fillStyle = d.alive ? '#8B4513' : '#f00'; // Brown for alive
                        this.ctx.beginPath();
                        this.ctx.ellipse(d.x, d.y, 30, 20, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.fillStyle = '#000';
                        this.ctx.beginPath();
                        this.ctx.arc(d.x - 10, d.y - 5, 3, 0, Math.PI * 2); // Eye
                        this.ctx.fill();
                    });

                    this.ctx.strokeStyle = '#f00';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.crosshair.x - 15, this.crosshair.y); this.ctx.lineTo(this.crosshair.x + 15, this.crosshair.y);
                    this.ctx.moveTo(this.crosshair.x, this.crosshair.y - 15); this.ctx.lineTo(this.crosshair.x, this.crosshair.y + 15);
                    this.ctx.stroke();

                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '20px Arial';
                    this.ctx.fillText(`Score: ${this.score}`, 10, 30);
                },
                start: function() {
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {
                    this.score = 0;
                    this.gameTime = 0;
                    this.ducks = [];
                }
            },
            pacman: {
                canvas: null, ctx: null,
                pacman: { x: 40, y: 300, dir: 0, nextDir: 0, mouth: 0 },
                ghosts: [
                    {x: 360, y: 280, dir: 0, color: '#f00'},
                    {x: 400, y: 280, dir: 1, color: '#0ff'},
                    {x: 440, y: 280, dir: 2, color: '#ff0'},
                    {x: 380, y: 320, dir: 3, color: '#f0f'}
                ],
                dots: [],
                score: 0,
                lives: 3,
                map: [
                    '11111111111111111111',
                    '10000000000000000001',
                    '10111101111011111001',
                    '10000000000000000001',
                    '10111101111011111001',
                    '10000000000000000001',
                    '10111101111011111001',
                    '10000000000000000001',
                    '10111101111011111001',
                    '10000000000000000001',
                    '11111111111111111111'
                ].join('').split('').map(c => c === '1' ? 1 : 0),
                tileSize: 40,
                keys: {},
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    this.lives = 3;
                    this.score = 0;
                    document.addEventListener('keydown', (e) => { this.keys[e.key] = true; e.preventDefault(); });
                    document.addEventListener('keyup', (e) => this.keys[e.key] = false);
                    this.resetGame();
                },
                resetGame: function() {
                    this.pacman = { x: 40, y: 300, dir: 0, nextDir: 0, mouth: 0 };
                    this.ghosts = [
                        {x: 360, y: 280, dir: 0, color: '#f00'},
                        {x: 400, y: 280, dir: 1, color: '#0ff'},
                        {x: 440, y: 280, dir: 2, color: '#ff0'},
                        {x: 380, y: 320, dir: 3, color: '#f0f'}
                    ];
                    this.generateDots();
                },
                generateDots: function() {
                    this.dots = [];
                    for (let y = 0; y < 11; y++) {
                        for (let x = 0; x < 20; x++) {
                            if (this.map[y * 20 + x] === 0) this.dots.push({x: x * this.tileSize + 20, y: y * this.tileSize + 20});
                        }
                    }
                },
                update: function() {
                    if (this.keys['ArrowRight']) this.pacman.nextDir = 0;
                    if (this.keys['ArrowDown']) this.pacman.nextDir = 1;
                    if (this.keys['ArrowLeft']) this.pacman.nextDir = 2;
                    if (this.keys['ArrowUp']) this.pacman.nextDir = 3;

                    let testDx = 0, testDy = 0;
                    const offset = 1;
                    if (this.pacman.nextDir === 0) testDx = offset;
                    if (this.pacman.nextDir === 1) testDy = offset;
                    if (this.pacman.nextDir === 2) testDx = -offset;
                    if (this.pacman.nextDir === 3) testDy = -offset;
                    let testTx = Math.floor((this.pacman.x + testDx) / this.tileSize);
                    let testTy = Math.floor((this.pacman.y + testDy) / this.tileSize);
                    if (testTx < 0 || testTx >= 20) testTx = (testTx + 20) % 20;
                    if (testTy < 0 || testTy >= 11) testTy = (testTy + 11) % 11;
                    if (this.map[testTy * 20 + testTx] !== 1) {
                        this.pacman.dir = this.pacman.nextDir;
                    }

                    let moveX = 0, moveY = 0;
                    if (this.pacman.dir === 0) moveX = 2;
                    if (this.pacman.dir === 1) moveY = 2;
                    if (this.pacman.dir === 2) moveX = -2;
                    if (this.pacman.dir === 3) moveY = -2;
                    let newX = this.pacman.x + moveX;
                    let newY = this.pacman.y + moveY;
                    let newTx = Math.floor(newX / this.tileSize);
                    let newTy = Math.floor(newY / this.tileSize);
                    if (newTx < 0 || newTx >= 20) newTx = (newTx + 20) % 20;
                    if (newTy < 0 || newTy >= 11) newTy = (newTy + 11) % 11;
                    if (this.map[newTy * 20 + newTx] !== 1) {
                        this.pacman.x = newX;
                        this.pacman.y = newY;
                    }

                    this.dots = this.dots.filter(d => {
                        const dx = this.pacman.x - d.x, dy = this.pacman.y - d.y;
                        if (Math.sqrt(dx*dx + dy*dy) < 15) {
                            this.score += 10;
                            return false;
                        }
                        return true;
                    });

                    this.ghosts.forEach(g => {
                        let targetDir = g.dir;
                        const dx = this.pacman.x - g.x;
                        const dy = this.pacman.y - g.y;
                        if (Math.random() < 0.3) { // Random element
                            targetDir = Math.floor(Math.random() * 4);
                        } else if (Math.abs(dx) > Math.abs(dy)) {
                            targetDir = dx > 0 ? 0 : 2;
                        } else {
                            targetDir = dy > 0 ? 1 : 3;
                        }

                        let testDx = 0, testDy = 0;
                        if (targetDir === 0) testDx = 1;
                        if (targetDir === 1) testDy = 1;
                        if (targetDir === 2) testDx = -1;
                        if (targetDir === 3) testDy = -1;
                        let testTx = Math.floor((g.x + testDx) / this.tileSize);
                        let testTy = Math.floor((g.y + testDy) / this.tileSize);
                        if (testTx < 0 || testTx >= 20) testTx = (testTx + 20) % 20;
                        if (testTy < 0 || testTy >= 11) testTy = (testTy + 11) % 11;
                        if (this.map[testTy * 20 + testTx] !== 1) {
                            g.dir = targetDir;
                        }

                        let gMoveX = 0, gMoveY = 0;
                        if (g.dir === 0) gMoveX = 1;
                        if (g.dir === 1) gMoveY = 1;
                        if (g.dir === 2) gMoveX = -1;
                        if (g.dir === 3) gMoveY = -1;
                        let gNewX = g.x + gMoveX;
                        let gNewY = g.y + gMoveY;
                        let gNewTx = Math.floor(gNewX / this.tileSize);
                        let gNewTy = Math.floor(gNewY / this.tileSize);
                        if (gNewTx < 0 || gNewTx >= 20) gNewTx = (gNewTx + 20) % 20;
                        if (gNewTy < 0 || gNewTy >= 11) gNewTy = (gNewTy + 11) % 11;
                        if (this.map[gNewTy * 20 + gNewTx] !== 1) {
                            g.x = gNewX;
                            g.y = gNewY;
                        } else {
                            g.dir = Math.floor(Math.random() * 4);
                        }

                        const pdx = this.pacman.x - g.x, pdy = this.pacman.y - g.y;
                        if (Math.sqrt(pdx*pdx + pdy*pdy) < 30) {
                            this.lives--;
                            if (this.lives <= 0) {
                                alert(`Game Over! Score: ${this.score}`);
                                this.lives = 3;
                                this.score = 0;
                            }
                            this.resetGame();
                        }
                    });

                    this.pacman.mouth = (this.pacman.mouth + 0.2) % (Math.PI * 2);

                    if (this.dots.length === 0) {
                        alert('Level Complete!');
                        this.resetGame();
                    }
                },
                draw: function() {
                    this.ctx.clearRect(0, 0, 800, 600);

                    for (let y = 0; y < 11; y++) {
                        for (let x = 0; x < 20; x++) {
                            const val = this.map[y * 20 + x];
                            if (val === 1) {
                                this.ctx.fillStyle = '#00f';
                                this.ctx.fillRect(x * this.tileSize, y * this.tileSize, this.tileSize, this.tileSize);
                            }
                        }
                    }

                    this.ctx.fillStyle = '#ff0';
                    this.dots.forEach(d => {
                        this.ctx.beginPath(); this.ctx.arc(d.x, d.y, 5, 0, Math.PI * 2); this.ctx.fill();
                    });

                    this.ctx.fillStyle = '#ff0';
                    this.ctx.save();
                    this.ctx.translate(this.pacman.x, this.pacman.y);
                    this.ctx.rotate(this.pacman.dir * Math.PI / 2);
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 20, this.pacman.mouth / 2, Math.PI * 2 - this.pacman.mouth / 2);
                    this.ctx.lineTo(0, 0);
                    this.ctx.fill();
                    this.ctx.restore();

                    this.ghosts.forEach(g => {
                        this.ctx.fillStyle = g.color;
                        this.ctx.beginPath();
                        this.ctx.arc(g.x, g.y, 20, 0, Math.PI * 2);
                        this.ctx.fill();
                    });

                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '20px Arial';
                    this.ctx.fillText(`Score: ${this.score} Lives: ${this.lives}`, 10, 30);
                },
                start: function() {
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {
                    this.lives = 3;
                    this.score = 0;
                }
            },
            '2048': {
                canvas: null, ctx: null,
                board: [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]],
                score: 0,
                keys: {},
                gameOver: false,
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    this.score = 0;
                    this.gameOver = false;
                    this.board = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
                    document.addEventListener('keydown', (e) => { this.keys[e.key] = true; e.preventDefault(); });
                    document.addEventListener('keyup', (e) => this.keys[e.key] = false);
                    this.addRandomTile();
                    this.addRandomTile();
                },
                addRandomTile: function() {
                    const empty = [];
                    this.board.forEach((row, y) => row.forEach((val, x) => { if (val === 0) empty.push({x, y}); }));
                    if (empty.length) {
                        const pos = empty[Math.floor(Math.random() * empty.length)];
                        this.board[pos.y][pos.x] = Math.random() > 0.9 ? 4 : 2;
                    }
                },
                move: function(dir) {
                    if (this.gameOver) return;
                    let moved = false;
                    const newBoard = this.board.map(row => [...row]);
                    const merge = (arr) => {
                        let merged = arr.filter(n => n !== 0);
                        for (let i = 0; i < merged.length - 1; i++) {
                            if (merged[i] === merged[i + 1]) {
                                merged[i] *= 2;
                                this.score += merged[i];
                                merged.splice(i + 1, 1);
                                moved = true;
                                i--;
                            }
                        }
                        while (merged.length < 4) merged.push(0);
                        return merged;
                    };
                    if (dir === 'ArrowLeft' || dir === 'a') {
                        for (let y = 0; y < 4; y++) {
                            newBoard[y] = merge(this.board[y]);
                        }
                    }
                    if (dir === 'ArrowRight' || dir === 'd') {
                        for (let y = 0; y < 4; y++) {
                            newBoard[y] = merge(this.board[y].reverse()).reverse();
                        }
                    }
                    if (dir === 'ArrowUp' || dir === 'w') {
                        for (let x = 0; x < 4; x++) {
                            let col = [this.board[0][x], this.board[1][x], this.board[2][x], this.board[3][x]];
                            col = merge(col);
                            for (let y = 0; y < 4; y++) newBoard[y][x] = col[y];
                        }
                    }
                    if (dir === 'ArrowDown' || dir === 's') {
                        for (let x = 0; x < 4; x++) {
                            let col = [this.board[0][x], this.board[1][x], this.board[2][x], this.board[3][x]].reverse();
                            col = merge(col).reverse();
                            for (let y = 0; y < 4; y++) newBoard[y][x] = col[y];
                        }
                    }
                    if (moved) {
                        this.board = newBoard;
                        this.addRandomTile();
                    }
                    this.checkGameOver();
                },
                checkGameOver: function() {
                    if (this.board.flat().includes(0)) return this.gameOver = false;
                    for (let y = 0; y < 4; y++) {
                        for (let x = 0; x < 3; x++) {
                            if (this.board[y][x] === this.board[y][x+1]) return this.gameOver = false;
                        }
                    }
                    for (let x = 0; x < 4; x++) {
                        for (let y = 0; y < 3; y++) {
                            if (this.board[y][x] === this.board[y+1][x]) return this.gameOver = false;
                        }
                    }
                    this.gameOver = true;
                },
                update: function() {
                    if (this.keys['ArrowLeft'] || this.keys['a']) { this.move('ArrowLeft'); this.keys['ArrowLeft'] = this.keys['a'] = false; }
                    if (this.keys['ArrowRight'] || this.keys['d']) { this.move('ArrowRight'); this.keys['ArrowRight'] = this.keys['d'] = false; }
                    if (this.keys['ArrowUp'] || this.keys['w']) { this.move('ArrowUp'); this.keys['ArrowUp'] = this.keys['w'] = false; }
                    if (this.keys['ArrowDown'] || this.keys['s']) { this.move('ArrowDown'); this.keys['ArrowDown'] = this.keys['s'] = false; }
                },
                draw: function() {
                    this.ctx.clearRect(0, 0, 400, 400);
                    const ts = 100;
                    for (let y = 0; y < 4; y++) {
                        for (let x = 0; x < 4; x++) {
                            const val = this.board[y][x];
                            this.ctx.fillStyle = val ? `hsl(${90 - Math.log2(val) * 5}, 70%, ${50 + Math.log2(val) * 5}%)` : '#222';
                            this.ctx.fillRect(x * ts, y * ts, ts, ts);
                            this.ctx.strokeStyle = '#000';
                            this.ctx.strokeRect(x * ts, y * ts, ts, ts);
                            if (val) {
                                this.ctx.fillStyle = val > 8 ? '#fff' : '#000';
                                this.ctx.font = 'bold 40px Arial';
                                this.ctx.textAlign = 'center';
                                this.ctx.fillText(val, x * ts + 50, y * ts + 65);
                            }
                        }
                    }
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '20px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(`Score: ${this.score}`, 10, 30);
                    if (this.gameOver) {
                        this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        this.ctx.fillRect(0, 150, 400, 100);
                        this.ctx.fillStyle = '#fff';
                        this.ctx.font = '30px Arial';
                        this.ctx.fillText('Game Over!', 100, 200);
                    }
                },
                start: function() {
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {
                    this.score = 0;
                    this.gameOver = false;
                }
            },
            tictactoe: {
                canvas: null, ctx: null,
                board: [[0,0,0],[0,0,0],[0,0,0]],
                currentPlayer: 1,
                gameOver: false,
                winner: 0,
                init: function(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    this.reset();
                    canvas.addEventListener('click', (e) => this.handleClick(e));
                },
                reset: function() {
                    this.board = [[0,0,0],[0,0,0],[0,0,0]];
                    this.currentPlayer = 1;
                    this.gameOver = false;
                    this.winner = 0;
                },
                handleClick: function(e) {
                    if (this.gameOver || this.currentPlayer !== 1) return;
                    const rect = this.canvas.getBoundingClientRect();
                    const x = Math.floor((e.clientX - rect.left) / 100);
                    const y = Math.floor((e.clientY - rect.top) / 100);
                    if (this.board[y][x] === 0) {
                        this.board[y][x] = 1;
                        this.checkWin();
                        if (!this.gameOver) {
                            this.currentPlayer = -1;
                            this.aiMove();
                        }
                    }
                },
                aiMove: function() {
                    if (this.gameOver) return;
                    let bestScore = -Infinity;
                    let bestMove = null;
                    for (let y = 0; y < 3; y++) {
                        for (let x = 0; x < 3; x++) {
                            if (this.board[y][x] === 0) {
                                this.board[y][x] = -1;
                                let score = this.minimax(this.board, 1);
                                this.board[y][x] = 0;
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestMove = {y, x};
                                }
                            }
                        }
                    }
                    if (bestMove) {
                        this.board[bestMove.y][bestMove.x] = -1;
                        this.checkWin();
                        this.currentPlayer = 1;
                    }
                },
                minimax: function(board, player) {
                    const result = this.checkWinSim(board);
                    if (result === 1) return -10;
                    if (result === -1) return 10;
                    if (result === 'draw') return 0;

                    let bestScore = player === -1 ? -Infinity : Infinity;
                    for (let y = 0; y < 3; y++) {
                        for (let x = 0; x < 3; x++) {
                            if (board[y][x] === 0) {
                                board[y][x] = player;
                                let score = this.minimax(board, -player);
                                board[y][x] = 0;
                                bestScore = player === -1 ? Math.max(score, bestScore) : Math.min(score, bestScore);
                            }
                        }
                    }
                    return bestScore;
                },
                checkWinSim: function(board) {
                    const lines = [
                        [board[0][0], board[0][1], board[0][2]],
                        [board[1][0], board[1][1], board[1][2]],
                        [board[2][0], board[2][1], board[2][2]],
                        [board[0][0], board[1][0], board[2][0]],
                        [board[0][1], board[1][1], board[2][1]],
                        [board[0][2], board[1][2], board[2][2]],
                        [board[0][0], board[1][1], board[2][2]],
                        [board[0][2], board[1][1], board[2][0]],
                    ];
                    for (let line of lines) {
                        if (line[0] === line[1] && line[1] === line[2] && line[0] !== 0) {
                            return line[0];
                        }
                    }
                    if (board.flat().every(cell => cell !== 0)) return 'draw';
                    return null;
                },
                checkWin: function() {
                    this.winner = this.checkWinSim(this.board);
                    if (this.winner || this.winner === 'draw') this.gameOver = true;
                },
                update: function() {},
                draw: function() {
                    this.ctx.clearRect(0, 0, 300, 300);
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(100, 0); this.ctx.lineTo(100, 300);
                    this.ctx.moveTo(200, 0); this.ctx.lineTo(200, 300);
                    this.ctx.moveTo(0, 100); this.ctx.lineTo(300, 100);
                    this.ctx.moveTo(0, 200); this.ctx.lineTo(300, 200);
                    this.ctx.stroke();

                    this.board.forEach((row, y) => {
                        row.forEach((cell, x) => {
                            if (cell === 1) {
                                this.ctx.beginPath();
                                this.ctx.moveTo(x*100 + 20, y*100 + 20);
                                this.ctx.lineTo((x+1)*100 - 20, (y+1)*100 - 20);
                                this.ctx.moveTo(x*100 + 20, (y+1)*100 - 20);
                                this.ctx.lineTo((x+1)*100 - 20, y*100 + 20);
                                this.ctx.stroke();
                            } else if (cell === -1) {
                                this.ctx.beginPath();
                                this.ctx.arc(x*100 + 50, y*100 + 50, 40, 0, Math.PI * 2);
                                this.ctx.stroke();
                            }
                        });
                    });

                    if (this.gameOver) {
                        this.ctx.fillStyle = '#fff';
                        this.ctx.font = '20px Arial';
                        this.ctx.textAlign = 'center';
                        let msg = this.winner === 'draw' ? 'Draw!' : this.winner === 1 ? 'X Wins!' : 'O Wins!';
                        this.ctx.fillText(msg, 150, 280);
                    }
                },
                start: function() {
                    this.update = this.update.bind(this);
                    this.draw = this.draw.bind(this);
                    const loop = () => { this.update(); this.draw(); gameLoop = requestAnimationFrame(loop); };
                    loop();
                },
                stop: function() {
                    this.reset();
                }
            }
        };

        // Start with first game
        switchGame();
    </script>
</body>
</html>
